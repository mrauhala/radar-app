<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Radar Animation</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.5.0/ol.css">
  <style>
    html, body, #map { margin: 0; padding: 0; width: 100%; height: 100%; font-family: sans-serif; }
    #toolbar { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: white; display: flex; align-items: center; padding: 10px 20px; border-radius: 12px 12px 0 0; box-sizing: border-box; }
    .toolbar-btn { background: none; border: none; color: white; font-size: 16px; margin: 0 10px; cursor: pointer; padding: 6px 10px; border-radius: 6px; display: flex; align-items: center; transition: background 0.2s; }
    .toolbar-btn:hover { background: rgba(255,255,255,0.2); }
    .toolbar-btn svg { width: 20px; height: 20px; fill: white; }
    .speed-label { margin: 0 10px; font-size: 16px; }
    .time-display { margin-left: auto; text-align: right; }
    .time-display .time { font-size: 20px; font-weight: bold; }
    .time-display .date { font-size: 12px; }
    #progress-bar { position: absolute; bottom: 0; left: 0; height: 4px; width: 100%; background: #444; border-radius: 0 0 12px 12px; overflow: hidden; }
    #progress-bar-fill { height: 100%; width: 0%; background: #00aaff; transition: width 0.2s; }
    #countrySelect { background: none; border: 1px solid white; color: white; margin-right: 10px; padding: 4px 8px; border-radius: 6px; font-size: 14px; }
    #loadingIndicator { display: none; align-items: center; margin-left: 10px; }
    .spinner { width: 16px; height: 16px; border: 2px solid white; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 5px; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  </style>
</head>
<body>
<div id="map"></div>
<div id="toolbar">
  <select id="countrySelect">
    <option value="ethiopia">Ethiopia</option>
    <option value="vietnam">Vietnam</option>
    <option value="georgia">Georgia</option>
  </select>
  <button class="toolbar-btn" id="toggleBaseBtn" title="Toggle Light/Dark">
    <svg viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 1 0 21 12.79z"/></svg>
  </button>
  <button class="toolbar-btn" id="opacityBtn" title="Opacity">70%</button>
  <button class="toolbar-btn speed-label">2×</button>
  <button class="toolbar-btn" id="prevBtn" title="Previous">
    <svg viewBox="0 0 24 24"><path d="M10 6v12l-6-6 6-6zm2 0h2v12h-2z"/></svg>
  </button>
  <button class="toolbar-btn" id="playPauseBtn" title="Pause">
    <svg id="playIcon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
  </button>
  <button class="toolbar-btn" id="nextBtn" title="Next">
    <svg viewBox="0 0 24 24"><path d="M14 6v12l6-6-6-6zm-2 0h-2v12h2z"/></svg>
  </button>
  <div class="time-display">
    <div class="time">--.--</div>
    <div class="date">--.--.----</div>
  </div>
  <div id="loadingIndicator">
    <div class="spinner"></div>
    <span>Loading…</span>
  </div>
</div>
<div id="progress-bar"><div id="progress-bar-fill"></div></div>
<script src="https://cdn.jsdelivr.net/npm/ol@v10.5.0/dist/ol.js"></script>
<script>
(async function() {
let map;
const wmsConfigs = {
  ethiopia: { wmsUrl: 'https://data-ethiopia.smartmet.org/wms', layerName: 'radar:composite_dbz' },
  vietnam: { wmsUrl: 'https://data.apps.nchmf.gov.vn/wms', layerName: 'vnmha:radar:comp_dbz' },
  georgia: { wmsUrl: 'https://data.nea.gov.ge/wms', layerName: 'radar:composite_dbz' }
};
let currentBase = localStorage.getItem('lastBase') || 'light';
let currentOpacity = parseFloat(localStorage.getItem('lastOpacity')) || 0.7;
let speedIndex = parseInt(localStorage.getItem('lastSpeedIndex')) || 1;
let intervalDelay = [450, 225, 150, 113][speedIndex];
const speeds = [450, 225, 150, 113];
let prefetchedFrames = [], currentFrame = 0, intervalId = null, isPlaying = true;
const countrySelect = document.getElementById('countrySelect');
const toggleBaseBtn = document.getElementById('toggleBaseBtn');
const opacityBtn = document.getElementById('opacityBtn');
const playPauseBtn = document.getElementById('playPauseBtn');
const nextBtn = document.getElementById('nextBtn');
const prevBtn = document.getElementById('prevBtn');
const speedLabel = document.querySelector('.speed-label');
const playIcon = document.getElementById('playIcon');
const timeDisplay = document.querySelector('.time-display .time');
const dateDisplay = document.querySelector('.time-display .date');
const progressFill = document.getElementById('progress-bar-fill');
const loadingIndicator = document.getElementById('loadingIndicator');
const currentConfig = wmsConfigs[localStorage.getItem('lastCountry') || 'ethiopia'];
countrySelect.value = localStorage.getItem('lastCountry') || 'ethiopia';
speedLabel.textContent = `${speedIndex + 1}×`;
opacityBtn.textContent = `${Math.round(currentOpacity * 100)}%`;
let layerExtent = [-20037508, -20037508, 20037508, 20037508];
let imageCanvasSource, imageCanvasLayer, baseLayerLight, baseLayerDark, overlayLayerLight, overlayLayerDark;
countrySelect.addEventListener('change', async e => {
  localStorage.setItem('lastCountry', e.target.value);
  stopAnimation();
  await initMap(wmsConfigs[e.target.value]);
  startAnimation();
});
opacityBtn.addEventListener('click', () => {
  currentOpacity += 0.1;
  if (currentOpacity > 1) currentOpacity = 0.1;
  localStorage.setItem('lastOpacity', currentOpacity);
  imageCanvasLayer.setOpacity(currentOpacity);
  opacityBtn.textContent = `${Math.round(currentOpacity * 100)}%`;
});
toggleBaseBtn.addEventListener('click', () => {
  currentBase = currentBase === 'light' ? 'dark' : 'light';
  localStorage.setItem('lastBase', currentBase);
  map.getLayers().setAt(0, currentBase === 'light' ? baseLayerLight : baseLayerDark);
  map.getLayers().setAt(2, currentBase === 'light' ? overlayLayerLight : overlayLayerDark);
});
speedLabel.addEventListener('click', () => {
  speedIndex = (speedIndex + 1) % speeds.length;
  intervalDelay = speeds[speedIndex];
  speedLabel.textContent = `${speedIndex + 1}×`;
  localStorage.setItem('lastSpeedIndex', speedIndex);
  if (isPlaying) startAnimation();
});
playPauseBtn.addEventListener('click', () => { isPlaying ? stopAnimation() : startAnimation(); });
nextBtn.addEventListener('click', () => { stopAnimation(); nextFrame(); });
prevBtn.addEventListener('click', () => { stopAnimation(); prevFrame(); });
function parsePeriodTimes(raw) {
  const [start, end, period] = raw.split('/').map(s => s.trim());
  const startDate = new Date(start), endDate = new Date(end);
  const minutes = /PT(\d+)M/.exec(period) ? parseInt(/PT(\d+)M/.exec(period)[1], 10) : 10;
  const result = [];
  for (let d = new Date(startDate); d <= endDate; d.setMinutes(d.getMinutes() + minutes)) {
    result.push(d.toISOString());
  }
  return result;
}
async function fetchTimes(config) {
  const xml = await (await fetch(`${config.wmsUrl}?service=WMS&request=GetCapabilities`)).text();
  const doc = new DOMParser().parseFromString(xml, 'text/xml');
  const layerNode = Array.from(doc.getElementsByTagName('Layer')).find(l => l.querySelector('Name')?.textContent === config.layerName);
  if (!layerNode) return [];
  const bbox = layerNode.querySelector('BoundingBox[CRS="EPSG:3857"], BoundingBox[SRS="EPSG:3857"]');
  if (bbox) layerExtent = [bbox.getAttribute('minx'), bbox.getAttribute('miny'), bbox.getAttribute('maxx'), bbox.getAttribute('maxy')].map(parseFloat);
  const dim = layerNode.querySelector('Dimension[name="time"]');
  return dim.textContent.includes(',') ? dim.textContent.split(',').slice(-12) : parsePeriodTimes(dim.textContent).slice(-12);
}
async function preloadFrames(config, times) {
  loadingIndicator.style.display = 'flex';
  const promises = times.map(time => new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve({ img, time });
    img.onerror = () => resolve(null);
    img.src = `${config.wmsUrl}?service=WMS&version=1.3.0&request=GetMap&layers=${config.layerName}&styles=&format=image/svg+xml&transparent=true&crs=EPSG:3857&bbox=${layerExtent.join(',')}&width=4096&height=4096&time=${time}`.replace(/\+/g, '%2B');
  }));
  prefetchedFrames = (await Promise.all(promises)).filter(f => f);
  loadingIndicator.style.display = 'none';
}
function updateDisplays() {
  const frameTime = new Date(prefetchedFrames[currentFrame].time);
  timeDisplay.textContent = `${frameTime.getUTCHours().toString().padStart(2, '0')}.${frameTime.getUTCMinutes().toString().padStart(2, '0')} UTC`;
  dateDisplay.textContent = `${frameTime.getUTCDate()}.${frameTime.getUTCMonth() + 1}.${frameTime.getUTCFullYear()}`;
  progressFill.style.width = `${(currentFrame / (prefetchedFrames.length - 1)) * 100}%`;
}
function nextFrame() { currentFrame = (currentFrame + 1) % prefetchedFrames.length; imageCanvasSource.changed(); updateDisplays(); }
function prevFrame() { currentFrame = (currentFrame - 1 + prefetchedFrames.length) % prefetchedFrames.length; imageCanvasSource.changed(); updateDisplays(); }
function startAnimation() { clearInterval(intervalId); intervalId = setInterval(nextFrame, intervalDelay); isPlaying = true; playIcon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'; }
function stopAnimation() { clearInterval(intervalId); intervalId = null; isPlaying = false; playIcon.innerHTML = '<path d="M8 5v14l11-7z"/>'; }
async function initMap(config) {
  const times = await fetchTimes(config);
  await preloadFrames(config, times);
  imageCanvasSource = new ol.source.ImageCanvas({
    canvasFunction: (extent, res, ratio, size) => {
      const canvas = document.createElement('canvas');
      canvas.width = size[0];
      canvas.height = size[1];
      const ctx = canvas.getContext('2d');
      const img = prefetchedFrames[currentFrame].img;
      const scaleX = size[0] / (extent[2] - extent[0]) * (layerExtent[2] - layerExtent[0]) / img.width;
      const scaleY = size[1] / (extent[3] - extent[1]) * (layerExtent[3] - layerExtent[1]) / img.height;
      const dx = (layerExtent[0] - extent[0]) / (extent[2] - extent[0]) * size[0];
      const dy = (extent[3] - layerExtent[3]) / (extent[3] - extent[1]) * size[1];
      ctx.setTransform(scaleX, 0, 0, scaleY, dx, dy);
      ctx.drawImage(img, 0, 0);
      return canvas;
    },
    projection: 'EPSG:3857', ratio: 1, imageExtent: layerExtent
  });
  imageCanvasLayer = new ol.layer.Image({ source: imageCanvasSource, opacity: currentOpacity });
  baseLayerLight = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}' }) });
  baseLayerDark = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}' }) });
  overlayLayerLight = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}' }) });
  overlayLayerDark = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}' }) });
  if (!map) {
    map = new ol.Map({
      target: 'map',
      layers: [currentBase === 'light' ? baseLayerLight : baseLayerDark, imageCanvasLayer, currentBase === 'light' ? overlayLayerLight : overlayLayerDark],
      view: new ol.View({ center: ol.extent.getCenter(layerExtent), zoom: 5, projection: 'EPSG:3857' })
    });
  } else {
    map.getLayers().setAt(1, imageCanvasLayer);
  }
  map.getView().fit(layerExtent, { size: map.getSize() });
  currentFrame = 0;
  updateDisplays();
  startAnimation();
}
await initMap(currentConfig);
})();
</script>
</body>
</html>
